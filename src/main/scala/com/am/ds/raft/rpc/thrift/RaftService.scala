/**
 * Generated by Scrooge
 *   version: 3.14.1
 *   rev: a996c1128a032845c508102d62e65fc0aa7a5f41
 *   built at: 20140501-114733
 */
package com.am.ds.raft.rpc.thrift

import com.twitter.scrooge.{
  TFieldBlob, ThriftService, ThriftStruct, ThriftStructCodec, ThriftStructCodec3, ThriftStructFieldInfo, ThriftUtil}
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait RaftService[+MM[_]] extends ThriftService {
  
  def sendRequestVote(requestVote: RequestVoteST): MM[RequestVoteResponseST]
  
  def sendAppendEntries(appendEntries: AppendEntriesST): MM[AppendEntriesResponseST]
  
  def forwardCommand(command: ByteBuffer): MM[ByteBuffer]
  
  def installSnapshot(installSnapshot: InstallSnapshotST): MM[Boolean]
  
  def join(memberId: JoinRequestST): MM[JoinResponseST]
  
  def getMembers(): MM[GetMembersResponseST]
}


object RaftService {
  
  object sendRequestVote$args extends ThriftStructCodec3[sendRequestVote$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("sendRequestVote_args")
    val RequestVoteField = new TField("requestVote", TType.STRUCT, 1)
    val RequestVoteFieldManifest = implicitly[Manifest[RequestVoteST]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        RequestVoteField,
        false,
        RequestVoteFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendRequestVote$args) {
    }
  
    override def encode(_item: sendRequestVote$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): sendRequestVote$args = {
      var requestVote: RequestVoteST = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  requestVote = readRequestVoteValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'requestVote' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new sendRequestVote$args(
        requestVote,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      requestVote: RequestVoteST
    ): sendRequestVote$args =
      new sendRequestVote$args(
        requestVote
      )
  
    def unapply(_item: sendRequestVote$args): Option[RequestVoteST] = Some(_item.requestVote)
  
  
    private def readRequestVoteValue(_iprot: TProtocol): RequestVoteST = {
      RequestVoteST.decode(_iprot)
    }
  
    private def writeRequestVoteField(requestVote_item: RequestVoteST, _oprot: TProtocol) {
      _oprot.writeFieldBegin(RequestVoteField)
      writeRequestVoteValue(requestVote_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeRequestVoteValue(requestVote_item: RequestVoteST, _oprot: TProtocol) {
      requestVote_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class sendRequestVote$args(
      val requestVote: RequestVoteST,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[RequestVoteST]
    with java.io.Serializable
  {
    import sendRequestVote$args._
      def this(
        requestVote: RequestVoteST
      ) = this(
        requestVote,
        Map.empty
      )
  
    def _1 = requestVote
  
  
    override def write(_oprot: TProtocol) {
      sendRequestVote$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (requestVote ne null) writeRequestVoteField(requestVote, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      requestVote: RequestVoteST = this.requestVote,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): sendRequestVote$args =
      new sendRequestVote$args(
        requestVote,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendRequestVote$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[sendRequestVote$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.requestVote
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendRequestVote$args"
  }
  
  object sendRequestVote$result extends ThriftStructCodec3[sendRequestVote$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("sendRequestVote_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[RequestVoteResponseST]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendRequestVote$result) {
    }
  
    override def encode(_item: sendRequestVote$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): sendRequestVote$result = {
      var success: Option[RequestVoteResponseST] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRUCT => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new sendRequestVote$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[RequestVoteResponseST] = None
    ): sendRequestVote$result =
      new sendRequestVote$result(
        success
      )
  
    def unapply(_item: sendRequestVote$result): Option[Option[RequestVoteResponseST]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): RequestVoteResponseST = {
      RequestVoteResponseST.decode(_iprot)
    }
  
    private def writeSuccessField(success_item: RequestVoteResponseST, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: RequestVoteResponseST, _oprot: TProtocol) {
      success_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class sendRequestVote$result(
      val success: Option[RequestVoteResponseST],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[RequestVoteResponseST]]
    with java.io.Serializable
  {
    import sendRequestVote$result._
      def this(
        success: Option[RequestVoteResponseST] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      sendRequestVote$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[RequestVoteResponseST] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): sendRequestVote$result =
      new sendRequestVote$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendRequestVote$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[sendRequestVote$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendRequestVote$result"
  }
  
  object sendAppendEntries$args extends ThriftStructCodec3[sendAppendEntries$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("sendAppendEntries_args")
    val AppendEntriesField = new TField("appendEntries", TType.STRUCT, 1)
    val AppendEntriesFieldManifest = implicitly[Manifest[AppendEntriesST]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        AppendEntriesField,
        false,
        AppendEntriesFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendAppendEntries$args) {
    }
  
    override def encode(_item: sendAppendEntries$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): sendAppendEntries$args = {
      var appendEntries: AppendEntriesST = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  appendEntries = readAppendEntriesValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'appendEntries' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new sendAppendEntries$args(
        appendEntries,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      appendEntries: AppendEntriesST
    ): sendAppendEntries$args =
      new sendAppendEntries$args(
        appendEntries
      )
  
    def unapply(_item: sendAppendEntries$args): Option[AppendEntriesST] = Some(_item.appendEntries)
  
  
    private def readAppendEntriesValue(_iprot: TProtocol): AppendEntriesST = {
      AppendEntriesST.decode(_iprot)
    }
  
    private def writeAppendEntriesField(appendEntries_item: AppendEntriesST, _oprot: TProtocol) {
      _oprot.writeFieldBegin(AppendEntriesField)
      writeAppendEntriesValue(appendEntries_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeAppendEntriesValue(appendEntries_item: AppendEntriesST, _oprot: TProtocol) {
      appendEntries_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class sendAppendEntries$args(
      val appendEntries: AppendEntriesST,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[AppendEntriesST]
    with java.io.Serializable
  {
    import sendAppendEntries$args._
      def this(
        appendEntries: AppendEntriesST
      ) = this(
        appendEntries,
        Map.empty
      )
  
    def _1 = appendEntries
  
  
    override def write(_oprot: TProtocol) {
      sendAppendEntries$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (appendEntries ne null) writeAppendEntriesField(appendEntries, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      appendEntries: AppendEntriesST = this.appendEntries,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): sendAppendEntries$args =
      new sendAppendEntries$args(
        appendEntries,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendAppendEntries$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[sendAppendEntries$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.appendEntries
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendAppendEntries$args"
  }
  
  object sendAppendEntries$result extends ThriftStructCodec3[sendAppendEntries$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("sendAppendEntries_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[AppendEntriesResponseST]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: sendAppendEntries$result) {
    }
  
    override def encode(_item: sendAppendEntries$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): sendAppendEntries$result = {
      var success: Option[AppendEntriesResponseST] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRUCT => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new sendAppendEntries$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[AppendEntriesResponseST] = None
    ): sendAppendEntries$result =
      new sendAppendEntries$result(
        success
      )
  
    def unapply(_item: sendAppendEntries$result): Option[Option[AppendEntriesResponseST]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): AppendEntriesResponseST = {
      AppendEntriesResponseST.decode(_iprot)
    }
  
    private def writeSuccessField(success_item: AppendEntriesResponseST, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: AppendEntriesResponseST, _oprot: TProtocol) {
      success_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class sendAppendEntries$result(
      val success: Option[AppendEntriesResponseST],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[AppendEntriesResponseST]]
    with java.io.Serializable
  {
    import sendAppendEntries$result._
      def this(
        success: Option[AppendEntriesResponseST] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      sendAppendEntries$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[AppendEntriesResponseST] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): sendAppendEntries$result =
      new sendAppendEntries$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[sendAppendEntries$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[sendAppendEntries$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "sendAppendEntries$result"
  }
  
  object forwardCommand$args extends ThriftStructCodec3[forwardCommand$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("forwardCommand_args")
    val CommandField = new TField("command", TType.STRING, 1)
    val CommandFieldManifest = implicitly[Manifest[ByteBuffer]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        CommandField,
        false,
        CommandFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: forwardCommand$args) {
    }
  
    override def encode(_item: forwardCommand$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): forwardCommand$args = {
      var command: ByteBuffer = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  command = readCommandValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'command' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new forwardCommand$args(
        command,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      command: ByteBuffer
    ): forwardCommand$args =
      new forwardCommand$args(
        command
      )
  
    def unapply(_item: forwardCommand$args): Option[ByteBuffer] = Some(_item.command)
  
  
    private def readCommandValue(_iprot: TProtocol): ByteBuffer = {
      _iprot.readBinary()
    }
  
    private def writeCommandField(command_item: ByteBuffer, _oprot: TProtocol) {
      _oprot.writeFieldBegin(CommandField)
      writeCommandValue(command_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeCommandValue(command_item: ByteBuffer, _oprot: TProtocol) {
      _oprot.writeBinary(command_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class forwardCommand$args(
      val command: ByteBuffer,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[ByteBuffer]
    with java.io.Serializable
  {
    import forwardCommand$args._
      def this(
        command: ByteBuffer
      ) = this(
        command,
        Map.empty
      )
  
    def _1 = command
  
  
    override def write(_oprot: TProtocol) {
      forwardCommand$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (command ne null) writeCommandField(command, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      command: ByteBuffer = this.command,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): forwardCommand$args =
      new forwardCommand$args(
        command,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[forwardCommand$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[forwardCommand$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.command
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "forwardCommand$args"
  }
  
  object forwardCommand$result extends ThriftStructCodec3[forwardCommand$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("forwardCommand_result")
    val SuccessField = new TField("success", TType.STRING, 0)
    val SuccessFieldManifest = implicitly[Manifest[ByteBuffer]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: forwardCommand$result) {
    }
  
    override def encode(_item: forwardCommand$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): forwardCommand$result = {
      var success: Option[ByteBuffer] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRING => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new forwardCommand$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[ByteBuffer] = None
    ): forwardCommand$result =
      new forwardCommand$result(
        success
      )
  
    def unapply(_item: forwardCommand$result): Option[Option[ByteBuffer]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): ByteBuffer = {
      _iprot.readBinary()
    }
  
    private def writeSuccessField(success_item: ByteBuffer, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: ByteBuffer, _oprot: TProtocol) {
      _oprot.writeBinary(success_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class forwardCommand$result(
      val success: Option[ByteBuffer],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[ByteBuffer]]
    with java.io.Serializable
  {
    import forwardCommand$result._
      def this(
        success: Option[ByteBuffer] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      forwardCommand$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[ByteBuffer] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): forwardCommand$result =
      new forwardCommand$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[forwardCommand$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[forwardCommand$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "forwardCommand$result"
  }
  
  object installSnapshot$args extends ThriftStructCodec3[installSnapshot$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("installSnapshot_args")
    val InstallSnapshotField = new TField("installSnapshot", TType.STRUCT, 1)
    val InstallSnapshotFieldManifest = implicitly[Manifest[InstallSnapshotST]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        InstallSnapshotField,
        false,
        InstallSnapshotFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: installSnapshot$args) {
    }
  
    override def encode(_item: installSnapshot$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): installSnapshot$args = {
      var installSnapshot: InstallSnapshotST = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  installSnapshot = readInstallSnapshotValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'installSnapshot' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new installSnapshot$args(
        installSnapshot,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      installSnapshot: InstallSnapshotST
    ): installSnapshot$args =
      new installSnapshot$args(
        installSnapshot
      )
  
    def unapply(_item: installSnapshot$args): Option[InstallSnapshotST] = Some(_item.installSnapshot)
  
  
    private def readInstallSnapshotValue(_iprot: TProtocol): InstallSnapshotST = {
      InstallSnapshotST.decode(_iprot)
    }
  
    private def writeInstallSnapshotField(installSnapshot_item: InstallSnapshotST, _oprot: TProtocol) {
      _oprot.writeFieldBegin(InstallSnapshotField)
      writeInstallSnapshotValue(installSnapshot_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeInstallSnapshotValue(installSnapshot_item: InstallSnapshotST, _oprot: TProtocol) {
      installSnapshot_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class installSnapshot$args(
      val installSnapshot: InstallSnapshotST,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[InstallSnapshotST]
    with java.io.Serializable
  {
    import installSnapshot$args._
      def this(
        installSnapshot: InstallSnapshotST
      ) = this(
        installSnapshot,
        Map.empty
      )
  
    def _1 = installSnapshot
  
  
    override def write(_oprot: TProtocol) {
      installSnapshot$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (installSnapshot ne null) writeInstallSnapshotField(installSnapshot, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      installSnapshot: InstallSnapshotST = this.installSnapshot,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): installSnapshot$args =
      new installSnapshot$args(
        installSnapshot,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[installSnapshot$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[installSnapshot$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.installSnapshot
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "installSnapshot$args"
  }
  
  object installSnapshot$result extends ThriftStructCodec3[installSnapshot$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("installSnapshot_result")
    val SuccessField = new TField("success", TType.BOOL, 0)
    val SuccessFieldManifest = implicitly[Manifest[Boolean]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: installSnapshot$result) {
    }
  
    override def encode(_item: installSnapshot$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): installSnapshot$result = {
      var success: Option[Boolean] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.BOOL => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.BOOL
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new installSnapshot$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[Boolean] = None
    ): installSnapshot$result =
      new installSnapshot$result(
        success
      )
  
    def unapply(_item: installSnapshot$result): Option[Option[Boolean]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): Boolean = {
      _iprot.readBool()
    }
  
    private def writeSuccessField(success_item: Boolean, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol) {
      _oprot.writeBool(success_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class installSnapshot$result(
      val success: Option[Boolean],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Boolean]]
    with java.io.Serializable
  {
    import installSnapshot$result._
      def this(
        success: Option[Boolean] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      installSnapshot$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Boolean] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): installSnapshot$result =
      new installSnapshot$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[installSnapshot$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[installSnapshot$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "installSnapshot$result"
  }
  
  object join$args extends ThriftStructCodec3[join$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("join_args")
    val MemberIdField = new TField("memberId", TType.STRUCT, 1)
    val MemberIdFieldManifest = implicitly[Manifest[JoinRequestST]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        MemberIdField,
        false,
        MemberIdFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: join$args) {
    }
  
    override def encode(_item: join$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): join$args = {
      var memberId: JoinRequestST = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  memberId = readMemberIdValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'memberId' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new join$args(
        memberId,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      memberId: JoinRequestST
    ): join$args =
      new join$args(
        memberId
      )
  
    def unapply(_item: join$args): Option[JoinRequestST] = Some(_item.memberId)
  
  
    private def readMemberIdValue(_iprot: TProtocol): JoinRequestST = {
      JoinRequestST.decode(_iprot)
    }
  
    private def writeMemberIdField(memberId_item: JoinRequestST, _oprot: TProtocol) {
      _oprot.writeFieldBegin(MemberIdField)
      writeMemberIdValue(memberId_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeMemberIdValue(memberId_item: JoinRequestST, _oprot: TProtocol) {
      memberId_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class join$args(
      val memberId: JoinRequestST,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[JoinRequestST]
    with java.io.Serializable
  {
    import join$args._
      def this(
        memberId: JoinRequestST
      ) = this(
        memberId,
        Map.empty
      )
  
    def _1 = memberId
  
  
    override def write(_oprot: TProtocol) {
      join$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (memberId ne null) writeMemberIdField(memberId, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      memberId: JoinRequestST = this.memberId,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): join$args =
      new join$args(
        memberId,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[join$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[join$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.memberId
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "join$args"
  }
  
  object join$result extends ThriftStructCodec3[join$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("join_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[JoinResponseST]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: join$result) {
    }
  
    override def encode(_item: join$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): join$result = {
      var success: Option[JoinResponseST] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRUCT => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new join$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[JoinResponseST] = None
    ): join$result =
      new join$result(
        success
      )
  
    def unapply(_item: join$result): Option[Option[JoinResponseST]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): JoinResponseST = {
      JoinResponseST.decode(_iprot)
    }
  
    private def writeSuccessField(success_item: JoinResponseST, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: JoinResponseST, _oprot: TProtocol) {
      success_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class join$result(
      val success: Option[JoinResponseST],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[JoinResponseST]]
    with java.io.Serializable
  {
    import join$result._
      def this(
        success: Option[JoinResponseST] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      join$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[JoinResponseST] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): join$result =
      new join$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[join$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[join$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "join$result"
  }
  
  object getMembers$args extends ThriftStructCodec3[getMembers$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("getMembers_args")
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: getMembers$args) {
    }
  
    override def encode(_item: getMembers$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): getMembers$args = {
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new getMembers$args(
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
    ): getMembers$args =
      new getMembers$args(
      )
  
    def unapply(_item: getMembers$args): Boolean = true
  
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class getMembers$args(
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product
    with java.io.Serializable
  {
    import getMembers$args._
      def this(
      ) = this(
        Map.empty
      )
  
  
  
    override def write(_oprot: TProtocol) {
      getMembers$args.validate(this)
      _oprot.writeStructBegin(Struct)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): getMembers$args =
      new getMembers$args(
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[getMembers$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[getMembers$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 0
  
    override def productElement(n: Int): Any = n match {
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "getMembers$args"
  }
  
  object getMembers$result extends ThriftStructCodec3[getMembers$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("getMembers_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[GetMembersResponseST]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: getMembers$result) {
    }
  
    override def encode(_item: getMembers$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): getMembers$result = {
      var success: Option[GetMembersResponseST] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRUCT => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new getMembers$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[GetMembersResponseST] = None
    ): getMembers$result =
      new getMembers$result(
        success
      )
  
    def unapply(_item: getMembers$result): Option[Option[GetMembersResponseST]] = Some(_item.success)
  
  
    private def readSuccessValue(_iprot: TProtocol): GetMembersResponseST = {
      GetMembersResponseST.decode(_iprot)
    }
  
    private def writeSuccessField(success_item: GetMembersResponseST, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: GetMembersResponseST, _oprot: TProtocol) {
      success_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class getMembers$result(
      val success: Option[GetMembersResponseST],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[GetMembersResponseST]]
    with java.io.Serializable
  {
    import getMembers$result._
      def this(
        success: Option[GetMembersResponseST] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      getMembers$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[GetMembersResponseST] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): getMembers$result =
      new getMembers$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[getMembers$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[getMembers$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "getMembers$result"
  }

  import com.twitter.util.Future

  trait FutureIface extends  RaftService[Future] {
    
    def sendRequestVote(requestVote: RequestVoteST): Future[RequestVoteResponseST]
    
    def sendAppendEntries(appendEntries: AppendEntriesST): Future[AppendEntriesResponseST]
    
    def forwardCommand(command: ByteBuffer): Future[ByteBuffer]
    
    def installSnapshot(installSnapshot: InstallSnapshotST): Future[Boolean]
    
    def join(memberId: JoinRequestST): Future[JoinResponseST]
    
    def getMembers(): Future[GetMembersResponseST]
  }

  class FinagledClient(
      service: com.twitter.finagle.Service[com.twitter.finagle.thrift.ThriftClientRequest, Array[Byte]],
      protocolFactory: TProtocolFactory = new TBinaryProtocol.Factory,
      serviceName: String = "",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver)
    extends RaftService$FinagleClient(
      service,
      protocolFactory,
      serviceName,
      stats)
    with FutureIface

  class FinagledService(
      iface: FutureIface,
      protocolFactory: TProtocolFactory)
    extends RaftService$FinagleService(
      iface,
      protocolFactory)
}